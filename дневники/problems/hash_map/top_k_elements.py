'''
ТОП K ВСТРЕЧАЮЩИХСЯ ЭЛЕМЕНТОВ

ЗАДАЧИ НА ПАТТЕРН КЛЮЧ-КОЛИЧЕСТВО И КОЛИЧЕСТВО-КЛЮЧ

Дан целочисленный массив nums и целое число k,
нужно вернуть k наиболее частых элементов. Можно вернуть ответ в любом порядке

пример
[5, 3, 1, 5, 5 ,3, 7] k=2 -> [5, 3] или [3, 5]

Первое что нужно сделать это подсчет. Создаем хэш таблицу
с ключем эелементом (число) и значением количество
5:3
3:2
1:1
7:1
Затем меняем их местами и сделаем это в массиве. Получится массив массивов
Где индекс подмассива это количество повторений числа или значение в хэш таблице
[][7 1][3][5 3]
 0  1   2   3

Почему при создании двухмерного массива, не будет квадратичной сложности?
Создание массива из n элементов, так как больше быть не может
(все эелементы разные и повторяются 1 раз),
в свою очередь один массив не может содержать больше чем n элементов 
(только одно число в примере [1, 1, 1, 1]), получается, что во всех массивах, 
суммарно n элементов. Тоесть всего будет эелементов 2n

Осталось пройтись по массивам и собрать ответ

Вся программа будет работать 
Время O(n) Память O(n)

Неосимптотическая оптимизация: оптимизация, которая будет работать быстрее в отдельных случаях,
но не повлияет на общую сложность алгоритма
Здесь мы можем добавлять массивы, только если понадобится необходимость, 
уменьшая количество пустых массивов
'''
from typing import List
class Solution():
    def topFrequent(self, nums: List[int], k: int) -> List[int]:
        count = {}
        for num in nums:
            if num not in count:
                count[num] = 0
            count[num] += 1

        frequency_list = [[] for i in range(len(nums) + 1)]
        for num in count:
            frequency = count[num]
            frequency_list[frequency].append(num)

        result = []
        for nums_list in reversed(frequency_list):
            for num in nums_list:
                if k <= 0:
                    return result
                result.append(num)
                k -= 1
        return result